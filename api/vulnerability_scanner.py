import asyncio
import json
import re
from typing import List, Dict, Any, Optional
from nvdlib import searchCVE
import textwrap
import logging
from flask_restful import Resource
from flask_praetorian import auth_required, current_user
from flask import current_app as app


# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Importar los modelos de la base de datos (asumiendo que están disponibles)
# from models import db, Sboom, Dependencia, Vulnerabilidad


class BuscadorCVE:
    def __init__(self, nvd_api_key=None):
        self.cache_cve = {}
        self.nvd_api_key = nvd_api_key

    def obtener_puntuacion_cvss(self, cve) -> float:
        """Extrae la puntuación CVSS del objeto CVE"""
        try:
            if hasattr(cve, 'metrics'):
                if hasattr(cve.metrics, 'cvssMetricV31') and cve.metrics.cvssMetricV31:
                    return float(cve.metrics.cvssMetricV31[0].cvssData.baseScore)
                elif hasattr(cve.metrics, 'cvssMetricV30') and cve.metrics.cvssMetricV30:
                    return float(cve.metrics.cvssMetricV30[0].cvssData.baseScore)
                elif hasattr(cve.metrics, 'cvssMetricV2') and cve.metrics.cvssMetricV2:
                    return float(cve.metrics.cvssMetricV2[0].cvssData.baseScore)
        except (AttributeError, IndexError, ValueError):
            pass
        return 0.0

    def obtener_etiqueta_severidad(self, puntuacion: float) -> str:
        """Convierte puntuación CVSS a etiqueta de severidad"""
        if puntuacion >= 9.0:
            return "CRITICAL"
        elif puntuacion >= 7.0:
            return "HIGH"
        elif puntuacion >= 4.0:
            return "MEDIUM"
        elif puntuacion > 0.0:
            return "LOW"
        else:
            return "UNKNOWN"

    def obtener_descripcion(self, cve) -> str:
        """Extrae descripción con preferencia de idioma"""
        try:
            # Preferir español, fallback a inglés
            for desc in cve.descriptions:
                if desc.lang == 'es':
                    return desc.value
            for desc in cve.descriptions:
                if desc.lang == 'en':
                    return desc.value
            return "Sin descripción disponible"
        except (AttributeError, IndexError):
            return "Sin descripción disponible"

    def version_afectada(self, cve, version_objetivo: str) -> bool:
        """Verifica si una versión específica está afectada por el CVE"""
        try:
            if not hasattr(cve, 'configurations') or not cve.configurations:
                return True  # Si no hay info de versión, asumir que puede estar afectada

            for config in cve.configurations:
                for node in config.nodes:
                    for match in node.cpeMatch:
                        if match.vulnerable:
                            # Verificar rangos de versión
                            version_start = getattr(match, 'versionStartIncluding', None)
                            version_end_exc = getattr(match, 'versionEndExcluding', None)
                            version_end_inc = getattr(match, 'versionEndIncluding', None)

                            # Si no hay restricciones de versión, está afectada
                            if not any([version_start, version_end_exc, version_end_inc]):
                                return True

                            # Verificar si la versión objetivo está en el rango afectado
                            if version_start and self.comparar_versiones(version_objetivo, version_start) < 0:
                                continue
                            if version_end_exc and self.comparar_versiones(version_objetivo, version_end_exc) >= 0:
                                continue
                            if version_end_inc and self.comparar_versiones(version_objetivo, version_end_inc) > 0:
                                continue

                            return True

            return False
        except Exception:
            return True  # En caso de error, asumir que está afectada

    def comparar_versiones(self, v1: str, v2: str) -> int:
        """Compara dos versiones. Retorna -1 si v1 < v2, 0 si v1 == v2, 1 si v1 > v2"""
        try:
            def normalizar_version(v):
                return [int(x) for x in re.sub(r'[^\d\.]', '', v).split('.') if x.isdigit()]

            v1_parts = normalizar_version(v1)
            v2_parts = normalizar_version(v2)

            # Rellenar con ceros para hacer listas del mismo tamaño
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))

            for i in range(max_len):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1

            return 0
        except Exception:
            return 0  # Si no se puede comparar, asumir iguales

    def producto_en_cpe(self, cve, nombre_producto: str) -> bool:
        """Verifica si el producto aparece en los CPEs del CVE"""
        try:
            if not hasattr(cve, 'configurations') or not cve.configurations:
                return False

            nombre_lower = nombre_producto.lower()
            
            for config in cve.configurations:
                for node in config.nodes:
                    for match in node.cpeMatch:
                        cpe_lower = match.criteria.lower()
                        # Buscar el nombre del producto en el CPE
                        if nombre_lower in cpe_lower:
                            return True
            return False
        except Exception:
            return False

    def buscar_vulnerabilidades_para_dependencia(self, nombre_producto: str, version: str = None) -> List[Dict[str, Any]]:
        """
        Busca vulnerabilidades para una dependencia específica.
        Retorna una lista de diccionarios con la información de vulnerabilidades.
        """
        vulnerabilidades_encontradas = []
        
        try:
            logger.info(f"Buscando vulnerabilidades para: {nombre_producto} v{version or 'any'}")
            
            # Primero intentar búsqueda por palabra clave
            resultados_brutos = searchCVE(keywordSearch=nombre_producto, limit=100)
            
            if resultados_brutos:
                # Filtrar CVEs que tengan el producto en sus CPEs
                resultados_filtrados = []
                for cve in resultados_brutos:
                    if self.producto_en_cpe(cve, nombre_producto):
                        resultados_filtrados.append(cve)

                # Si se especifica versión, filtrar por versión
                if version and resultados_filtrados:
                    resultados_version = []
                    for cve in resultados_filtrados:
                        if self.version_afectada(cve, version):
                            resultados_version.append(cve)
                    resultados_filtrados = resultados_version

                # Convertir CVEs a formato requerido por la base de datos
                for cve in resultados_filtrados:
                    puntuacion_cvss = self.obtener_puntuacion_cvss(cve)
                    severidad = self.obtener_etiqueta_severidad(puntuacion_cvss)
                    descripcion = self.obtener_descripcion(cve)
                    
                    vulnerabilidad_data = {
                        'cve_id': cve.id,
                        'descripcion': descripcion,
                        'puntuacion_cvss': puntuacion_cvss,
                        'severidad': severidad
                    }
                    
                    vulnerabilidades_encontradas.append(vulnerabilidad_data)
                    
                logger.info(f"Encontradas {len(vulnerabilidades_encontradas)} vulnerabilidades para {nombre_producto}")
                
            else:
                logger.info(f"No se encontraron vulnerabilidades para {nombre_producto}")

        except Exception as e:
            logger.error(f"Error buscando vulnerabilidades para {nombre_producto}: {e}")
            
        return vulnerabilidades_encontradas

    def buscar_por_cpe(self, patron_cpe: str, version: str = None) -> List[Dict[str, Any]]:
        """Busca CVEs específicamente por patrón CPE y retorna formato para BD"""
        vulnerabilidades_encontradas = []
        
        try:
            logger.info(f"Buscando CVEs por CPE: {patron_cpe}")
            
            resultados = searchCVE(cpeName=patron_cpe, limit=50)

            if resultados:
                # Filtrar por versión si se especifica
                if version:
                    resultados_filtrados = []
                    for cve in resultados:
                        if self.version_afectada(cve, version):
                            resultados_filtrados.append(cve)
                    resultados = resultados_filtrados

                # Convertir a formato de BD
                for cve in resultados:
                    puntuacion_cvss = self.obtener_puntuacion_cvss(cve)
                    severidad = self.obtener_etiqueta_severidad(puntuacion_cvss)
                    descripcion = self.obtener_descripcion(cve)
                    
                    vulnerabilidad_data = {
                        'cve_id': cve.id,
                        'descripcion': descripcion,
                        'puntuacion_cvss': puntuacion_cvss,
                        'severidad': severidad
                    }
                    
                    vulnerabilidades_encontradas.append(vulnerabilidad_data)

        except Exception as e:
            logger.error(f"Error buscando CVEs para CPE {patron_cpe}: {e}")
            
        return vulnerabilidades_encontradas


# Función standalone para compatibilidad con el código existente
def buscar_vulnerabilidades(nombre_producto: str, version: str = None, nvd_api_key: str = None) -> List[Dict[str, Any]]:
    """
    Función wrapper para mantener compatibilidad con el código existente.
    Busca vulnerabilidades para un producto y versión específicos.
    """
    buscador = BuscadorCVE(nvd_api_key=nvd_api_key)
    return buscador.buscar_vulnerabilidades_para_dependencia(nombre_producto, version)

