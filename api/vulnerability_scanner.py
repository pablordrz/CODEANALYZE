import asyncio
import json
import re
from typing import List, Dict, Any, Optional
from nvdlib import searchCVE
import textwrap
import logging
from flask_restful import Resource
from flask_praetorian import auth_required, current_user
from flask import current_app as app
import google.generativeai as genai


# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Importar los modelos de la base de datos (asumiendo que están disponibles)
# from models import db, Sboom, Dependencia, Vulnerabilidad


class BuscadorCVE:
    def __init__(self, nvd_api_key=None, gemini_api_key=None):
        self.cache_cve = {}
        self.nvd_api_key = nvd_api_key
        self.gemini_api_key = gemini_api_key
        if gemini_api_key:
            genai.configure(api_key=gemini_api_key)
            self.gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')

    def obtener_puntuacion_cvss(self, cve) -> float:
        """Extrae la puntuación CVSS del objeto CVE"""
        try:
            if hasattr(cve, 'metrics'):
                if hasattr(cve.metrics, 'cvssMetricV31') and cve.metrics.cvssMetricV31:
                    return float(cve.metrics.cvssMetricV31[0].cvssData.baseScore)
                elif hasattr(cve.metrics, 'cvssMetricV30') and cve.metrics.cvssMetricV30:
                    return float(cve.metrics.cvssMetricV30[0].cvssData.baseScore)
                elif hasattr(cve.metrics, 'cvssMetricV2') and cve.metrics.cvssMetricV2:
                    return float(cve.metrics.cvssMetricV2[0].cvssData.baseScore)
        except (AttributeError, IndexError, ValueError):
            pass
        return 0.0

    def obtener_etiqueta_severidad(self, puntuacion: float) -> str:
        """Convierte puntuación CVSS a etiqueta de severidad"""
        if puntuacion >= 9.0:
            return "CRITICAL"
        elif puntuacion >= 7.0:
            return "HIGH"
        elif puntuacion >= 4.0:
            return "MEDIUM"
        elif puntuacion > 0.0:
            return "LOW"
        else:
            return "UNKNOWN"

    def obtener_descripcion(self, cve) -> str:
        """Extrae descripción con preferencia de idioma"""
        try:
            # Preferir español, fallback a inglés
            for desc in cve.descriptions:
                if desc.lang == 'es':
                    return desc.value
            for desc in cve.descriptions:
                if desc.lang == 'en':
                    return desc.value
            return "Sin descripción disponible"
        except (AttributeError, IndexError):
            return "Sin descripción disponible"

    async def verificar_cves_con_gemini(self, cves_data: List[Dict], nombre_producto: str, version: str = None) -> List[str]:
        """
        Usa Gemini para verificar qué CVEs son correctos para la dependencia y versión específica.
        Retorna una lista de CVE IDs que Gemini confirma como correctos.
        """
        if not self.gemini_api_key or not hasattr(self, 'gemini_model'):
            logger.warning("Gemini API no configurada, retornando todos los CVEs")
            return [cve['cve_id'] for cve in cves_data]

        try:
            # Preparar la información de los CVEs para Gemini
            cves_info = []
            for cve in cves_data:
                cve_info = f"CVE ID: {cve['cve_id']}\n"
                cve_info += f"Descripción: {cve['descripcion']}\n"
                cve_info += f"Severidad: {cve['severidad']}\n"
                cve_info += f"Puntuación CVSS: {cve['puntuacion_cvss']}\n"
                cves_info.append(cve_info)

            cves_text = "\n---\n".join(cves_info)

            prompt = f"""
Actúa como un analista experto en seguridad de software. Tu tarea es determinar si los CVEs de una lista afectan a una dependencia y versión de software específicas.

**Dependencia a analizar:**
- Nombre del Producto: `{nombre_producto}`
- Versión a Verificar: `{version or 'No especificada'}`

**Lista de CVEs encontrados para "{nombre_producto}":**
---
{cves_text}
---

**Instrucciones Clave:**
1.  **Analiza cada CVE por separado.**
2.  **Verifica la Relevancia del Producto:** Asegúrate de que el CVE es para "{nombre_producto}". A menudo, una búsqueda por palabra clave puede traer CVEs de productos con nombres similares. Fíjate en los detalles de la descripción.
3.  **Verifica la Versión (Paso CRÍTICO):**
    *   Lee atentamente la descripción de cada CVE para encontrar información sobre las **versiones afectadas**.
    *   Compara la "Versión a Verificar" (`{version}`) con los rangos mencionados (ej. "todas las versiones anteriores a 2.5.13", "versiones desde 1.0 hasta 1.5", "versión 4.2.1").
    *   **Un CVE es relevante SÓLO SI la versión a verificar (`{version}`) cae DENTRO del rango de versiones afectadas.**
    *   Si un CVE no menciona explícitamente rangos de versión en su descripción, pero sí nombra al producto, debes considerarlo relevante, a menos que la descripción sugiera claramente que no aplica.
4.  **Tu Objetivo:** Producir una lista precisa de CVEs que afecten a la `{nombre_producto}` en su versión `{version}`.

**Formato de Respuesta Requerido:**
- Responde ÚNICAMENTE con una lista de los CVE IDs que has determinado como relevantes, separados por comas.
- Ejemplo: `CVE-2021-1234,CVE-2022-5678`
- Si después de tu análisis, NINGÚN CVE de la lista afecta a la dependencia y versión especificadas, responde con la palabra `NONE`.
"""

            response = await self.gemini_model.generate_content_async(prompt)
            result = response.text.strip()

            if result.upper() == "NONE":
                return []
            
            # Parsear la respuesta de Gemini
            cve_ids = [cve_id.strip() for cve_id in result.split(',') if cve_id.strip()]
            logger.info(f"Gemini confirmó {len(cve_ids)} CVEs como relevantes para {nombre_producto} v{version}")
            return cve_ids

        except Exception as e:
            logger.error(f"Error al verificar CVEs con Gemini: {e}")
            # En caso de error, retornar todos los CVEs
            return [cve['cve_id'] for cve in cves_data]

    def buscar_vulnerabilidades_para_dependencia(self, nombre_producto: str, version: str = None) -> List[Dict[str, Any]]:
        """
        Busca vulnerabilidades para una dependencia específica.
        Encuentra todos los CVEs relacionados y usa Gemini para verificar cuáles son correctos.
        Retorna solo el CVE de mayor criticidad de los verificados por Gemini.
        """
        vulnerabilidades_encontradas = []
        
        try:
            logger.info(f"Buscando vulnerabilidades para: {nombre_producto} v{version or 'any'}")
            
            # Buscar todos los CVEs relacionados con el producto
            resultados_brutos = searchCVE(keywordSearch=nombre_producto, limit=100)
            
            if resultados_brutos:
                # Convertir todos los CVEs a formato de datos
                todos_los_cves = []
                for cve in resultados_brutos:
                    puntuacion_cvss = self.obtener_puntuacion_cvss(cve)
                    severidad = self.obtener_etiqueta_severidad(puntuacion_cvss)
                    descripcion = self.obtener_descripcion(cve)
                    
                    cve_data = {
                        'cve_id': cve.id,
                        'descripcion': descripcion,
                        'puntuacion_cvss': puntuacion_cvss,
                        'severidad': severidad
                    }
                    todos_los_cves.append(cve_data)

                logger.info(f"Encontrados {len(todos_los_cves)} CVEs relacionados con {nombre_producto}")

                # Usar Gemini para verificar cuáles CVEs son correctos
                cves_verificados = asyncio.run(self.verificar_cves_con_gemini(todos_los_cves, nombre_producto, version))
                
                # Filtrar solo los CVEs verificados por Gemini
                for cve_data in todos_los_cves:
                    if cve_data['cve_id'] in cves_verificados:
                        vulnerabilidades_encontradas.append(cve_data)

                # Seleccionar el CVE de mayor criticidad
                if vulnerabilidades_encontradas:
                    severidades = {"LOW": 1, "MEDIUM": 2, "HIGH": 3, "CRITICAL": 4}
                    max_vuln = None
                    max_riesgo_num = 0
                    
                    for vuln in vulnerabilidades_encontradas:
                        riesgo_num = severidades.get(vuln['severidad'].upper(), 0) if vuln['severidad'] else 0
                        if riesgo_num > max_riesgo_num:
                            max_riesgo_num = riesgo_num
                            max_vuln = vuln
                    
                    # Retornar solo el CVE de mayor criticidad
                    if max_vuln:
                        vulnerabilidades_encontradas = [max_vuln]
                        logger.info(f"Seleccionado CVE de mayor criticidad: {max_vuln['cve_id']} ({max_vuln['severidad']}) para {nombre_producto}")
                    
                logger.info(f"Retornando 1 vulnerabilidad de mayor criticidad para {nombre_producto} v{version or 'any'}")
                
            else:
                logger.info(f"No se encontraron vulnerabilidades para {nombre_producto}")

        except Exception as e:
            logger.error(f"Error buscando vulnerabilidades para {nombre_producto}: {e}")
            
        return vulnerabilidades_encontradas

    def buscar_por_cpe(self, patron_cpe: str, version: str = None) -> List[Dict[str, Any]]:
        """Busca CVEs específicamente por patrón CPE y retorna formato para BD"""
        vulnerabilidades_encontradas = []
        
        try:
            logger.info(f"Buscando CVEs por CPE: {patron_cpe}")
            
            resultados = searchCVE(cpeName=patron_cpe, limit=50)

            if resultados:
                # Convertir a formato de BD
                for cve in resultados:
                    puntuacion_cvss = self.obtener_puntuacion_cvss(cve)
                    severidad = self.obtener_etiqueta_severidad(puntuacion_cvss)
                    descripcion = self.obtener_descripcion(cve)
                    
                    vulnerabilidad_data = {
                        'cve_id': cve.id,
                        'descripcion': descripcion,
                        'puntuacion_cvss': puntuacion_cvss,
                        'severidad': severidad
                    }
                    
                    vulnerabilidades_encontradas.append(vulnerabilidad_data)

        except Exception as e:
            logger.error(f"Error buscando CVEs para CPE {patron_cpe}: {e}")
            
        return vulnerabilidades_encontradas


# Función standalone para compatibilidad con el código existente
def buscar_vulnerabilidades(nombre_producto: str, version: str = None, nvd_api_key: str = None, gemini_api_key: str = None) -> List[Dict[str, Any]]:
    """
    Función wrapper para mantener compatibilidad con el código existente.
    Busca vulnerabilidades para un producto y versión específicos.
    """
    buscador = BuscadorCVE(nvd_api_key=nvd_api_key, gemini_api_key=gemini_api_key)
    return buscador.buscar_vulnerabilidades_para_dependencia(nombre_producto, version)

